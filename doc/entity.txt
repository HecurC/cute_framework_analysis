System
	Implements gameplay features (code)
	Contains singleton data
	Has associated component for looping

Component
	Contains only local data
		Has entity embedded (entity defined below)
	Functions operate only on local data
	Statically defined dependencies on other components, run-time asserted
	Has serialized format

Entity
	type id
		has associated blueprint schema for serialization
		schema can be visualized
		can inherit from another schema by referenced id and extend it
	unique run-time id
	embedded in components
	global table to determine alive status (entity System)

---

Open questions.
1. Is messaging necessary?
2. Do example implementation scenarios have glaring friction points?
3. Are there determinism problems?
4. Is there too many steps to make a new component or entity type (iteration friction)?
5. How would events (network events for gameplay) fit in?

---

Work through example problem.
Octorok example.

Systems
	System_Player
		Component_Player
		handle inputs
		look for things to interact with
	System_Octorok
		Component_Octorok
		control animations
		pathfinding
		fire projectiles
	System_Collider
		Component_Collider
		array of touch_entity events
		touch_entity event - Component_Collider id pair
	System_Sprite
		Component_Sprite
		update animation
		push sprite to batcher

Components
	Component_Transform
		rotation
		translation
	Component_Player
		unique id
	Component_Octorok
		array of live projectiles
	Component_Collider
		shape id
		local shape struct
		bool tile_collision
		my touch_category
		their touch_category
		array of touch_entity events
	Component_Sprite
		animation
		or single image frame

Run-time Entities
	Player - entity id player
		Component_Transform
		Component_Player
		Component_Sprite
		Component_Collider
	Octorok - entity id octorok
		Component_Transform
		Component_Octorok
		Component_Sprite
		Component_Collider

---

Conclusions.
1. My intuition says hard no. File inclusions are reduced by nature of composition, rendering messaging not useful.
2. Not shown from examples.
3. No. Rewind simply relies on queuing up invertible actions.
4. No problem here.
5. System_Event can encapsulate all details here.

---

Implementation details.

Any systems inheritance?
Yes, to type the array and deal with lookups.
Component inheritance?
Yes, for entity id and type.
Each system has an associated header, and maintains an array of it's matching component type.
Systems can retrieve components from other systems by entity id lookup.

---

Need a little more infrastructure on Systems otherwise the entire thing isn't useful.
Systems should be stored by string.
System is a pure virtual class.

Great!

Now I need a way to specify entity schemas and associate them with a type.
I also need a way to register component serializers based on string id.

Component initializer.
Simply writes out default values. User handles typecasting.

Component serializers.
A single function to serialize a component. The user can handle typecasting and logic.
They will get passed the kv context and component type.
A serializer is a function pointer and string pair. The string is the component name.
This trivially supports data inheritance - missing keys are safely ignored.
This means a single component serializer can support instance loading and data inheritance.

Data inheritance will be used on the entity level.
An entity can be constructed within the cute framework, along with the associated components.
Components are initialized with the user-supplied initializer functions.

Entities are registered with a schema, name, and type id.
The schema specifies components by type, and optionally overrides default values.

Example entity, Octorok schema.

{
	entity_name = "octorok",
	entity_id = 103,
	component_transform = {
	}
	component_octorok = {
	}
	component_sprite = {
		image = "/data/images/octorok.png",
	}
	component_collider = {
		type = "circle"
		radius = 3
		my_touch_categories = 102301,
		their_touch_catogries = 821904,
	},
},

Now I need to design entity instance format. It can look exactly like the schema.
However, there is an error if a component is listed here that is not in the schema.

So what might it look like to write a component serializer?
Don't want to serialize members that are already defaulted. So the user can write a custom read/write functions that differ.

---

Once serialized the entity and components need to be run-time initialized. For example, mapping serialized id's to run-time id's for various entities.
app should be able to load entities from a kv file.
Once finished the associated systems should be notified of which components are new (the ones at the end of their arrays).
That way they can patch any entity id's with the serialized id map.

Actually a built-in component for tracking entity ids that is serializeable is a great idea. RIGHT?

Perhaps this is a little too hard to design right now.

I'll deal with it later.

Probably best idea is simply to have a component specifically for holding other entity id's that knows how to serialize itself smartly.

---

Run the Octorok example.
Define the schema. Done.
Register it to the app. Done.
Load entities from a file.

{
	entity_type = "octorok",
	component_transform = {
		pos = {
			x = 10,
			y = 15,
		},
	}
},
{
	entity_type = "octorok",
	component_transform = {
		pos = {
			x = 15,
			y = 15,
		},
	}
},

Done I guess.

What does load entities do?
Loops over objects and looks for entity_name.
Then looks for each component type for instance data.
And that's it really.

---

What about saving entities?
Ew.
Well, instances of schemas, and then write "changed" or "instanced" values. So, in other words, it's up to the user.

---

So now within a system I am looking at this sort of memory access pattern and use case.

for each system
	for each component
		lookup entity
		lookup other necessary components

I think this is fine.
Making the API as simple as possible is the top goal.
Once different components are implemented entites can be created by mix and matching components.

---

Scratch this.

Entity type
	Incrementing id
	Gets assigned at runtime during type registration

Entity
	Entity type
	Handle

Entity Collection
	Array of component types
	Array of array of components
	Handle table
	Can look up components by handle

Entity System
	Dictionary of entity type to entity collections
	Can register entity types
	Can update all systems

System
	Set of component types
	Update function
	Takes components as parameters
	Takes entity id as parameter

Component
	Just byte data
	Has an initializer function
	Has a serializer function

---

Register component types.
Register entity types.
Register entity schema.
Load entity from string.
Call update on systems.

---

StateSystem
-> Queue up changes
-> Invoke processing later
-> Store/access data

---

Ways to get an entity_t.
Geometrically, within a system, via spatial query.
Already known via serialization (referenced in file).
Assigned in editor or UI.

---

// Serialize entities.
// Entities can refer to one another in serialized form.
// Can an entity refer to another entity in another file?

If an entity can refer to another entity in an entirely different file, then loading can happen at different times.
This means an id can be invalid until serialized later.
So id resolution would need to be pretty complicated.
I imagine entities on disk would only be able to refer to one another within a single file, for simplicity of implementation.

Serializing entities has a problem. How can I serialize only the instance data differing from the schema?
I need an efficient way to diff an entity with the schema for saving.

How would the diff work?
Loop over all key/value pairs, compare old value with new value, and serialize it if it's different.

---

ok great, can now serialize the diff
stupendous

but now
lifetimes of entities and serializing references to one another
nyaa

how does saving entities work

LOAD
* Each entity has implicit index in the file
* The index is the index of instance into the file
* Each reference is one of these indices
* When loading, a hash table is built to map file index to entity id
* After all entities are loaded, all references are patched
* I will need to store an array of entity reference pointers to patch

SAVE
* The user supplies an array of entity ids
* This is the order they are stored in file and implicitly defines ids
* A table is constructed to go from entity id to index
* Upon saving, all references are converted from runtime entity id to index

---

ya so saving is working
next problem

entity A refers to entity B
A wants to mutate B
how?

worst case scenario
	hit entity collection table, lookup by entity type
	hit component tables, lookup by component type
	hit component array, lookup by index

but if it's intra-system
	hit handle table to get index
	hit component array by index

so there should be two different kind of get component functions
since one is cleary faster

System
	Implements gameplay features (code)
	Contains singleton data
	Has associated component for looping

Component
	Contains only local data
		Has entity embedded (entity defined below)
	Functions operate only on local data
	Statically defined dependencies on other components, run-time asserted
	Has serialized format

Entity
	type id
		has associated blueprint schema for serialization
		schema can be visualized
		can inherit from another schema by referenced id and extend it
	unique run-time id
	embedded in components
	global table to determine alive status (entity System)

---

Open questions.
1. Is messaging necessary?
2. Do example implementation scenarios have glaring friction points?
3. Are there determinism problems?
4. Is there too many steps to make a new component or entity type (iteration friction)?
5. How would events (network events for gameplay) fit in?

---

Work through example problem.
Octorok example.

Systems
	System_Player
		Component_Player
		handle inputs
		look for things to interact with
	System_Octorok
		Component_Octorok
		control animations
		pathfinding
		fire projectiles
	System_Collider
		Component_Collider
		array of touch_entity events
		touch_entity event - Component_Collider id pair
	System_Sprite
		Component_Sprite
		update animation
		push sprite to batcher

Components
	Component_Transform
		rotation
		translation
	Component_Player
		unique id
	Component_Octorok
		array of live projectiles
	Component_Collider
		shape id
		local shape struct
		bool tile_collision
		my touch_category
		their touch_category
		array of touch_entity events
	Component_Sprite
		animation
		or single image frame

Run-time Entities
	Player - entity id player
		Component_Transform
		Component_Player
		Component_Sprite
		Component_Collider
	Octorok - entity id octorok
		Component_Transform
		Component_Octorok
		Component_Sprite
		Component_Collider

---

Conclusions.
1. My intuition says hard no. File inclusions are reduced by nature of composition, rendering messaging not useful.
2. Not shown from examples.
3. No. Rewind simply relies on queuing up invertible actions.
4. No problem here.
5. System_Event can encapsulate all details here.

---

Implementation details.

Any systems inheritance?
Yes, to type the array and deal with lookups.
Component inheritance?
Yes, for entity id and type.
Each system has an associated header, and maintains an array of it's matching component type.
Systems can retrieve components from other systems by entity id lookup.

---

Need a little more infrastructure on Systems otherwise the entire thing isn't useful.
Systems should be stored by string.
System is a pure virtual class.

Great!

Now I need a way to specify entity schemas and associate them with a type.
I also need a way to register component serializers based on string id.

Component initializer.
Simply writes out default values. User handles typecasting.

Component serializers.
A single function to serialize a component. The user can handle typecasting and logic.
They will get passed the kv context and component type.
A serializer is a function pointer and string pair. The string is the component name.
This trivially supports data inheritance - missing keys are safely ignored.
This means a single component serializer can support instance loading and data inheritance.

Data inheritance will be used on the entity level.
An entity can be constructed within the cute framework, along with the associated components.
Components are initialized with the user-supplied initializer functions.

Entities are registered with a schema, name, and type id.
The schema specifies components by type, and optionally overrides default values.

Example entity, Octorok schema.

{
	entity_name = "octorok",
	entity_id = 103,
	component_transform = {
	}
	component_octorok = {
	}
	component_sprite = {
		image = "/data/images/octorok.png",
	}
	component_collider = {
		type = "circle"
		radius = 3
		my_touch_categories = 102301,
		their_touch_catogries = 821904,
	},
},

Now I need to design entity instance format. It can look exactly like the schema.
However, there is an error if a component is listed here that is not in the schema.

So what might it look like to write a component serializer?
Don't want to serialize members that are already defaulted. So the user can write a custom read/write functions that differ.

---

Once serialized the entity and components need to be run-time initialized. For example, mapping serialized id's to run-time id's for various entities.
app should be able to load entities from a kv file.
Once finished the associated systems should be notified of which components are new (the ones at the end of their arrays).
That way they can patch any entity id's with the serialized id map.

Actually a built-in component for tracking entity ids that is serializeable is a great idea. RIGHT?

Perhaps this is a little too hard to design right now.

I'll deal with it later.

Probably best idea is simply to have a component specifically for holding other entity id's that knows how to serialize itself smartly.

---

Run the Octorok example.
Define the schema. Done.
Register it to the app. Done.
Load entities from a file.

{
	entity_type = "octorok",
	component_transform = {
		pos = {
			x = 10,
			y = 15,
		},
	}
},
{
	entity_type = "octorok",
	component_transform = {
		pos = {
			x = 15,
			y = 15,
		},
	}
},

Done I guess.

What does load entities do?
Loops over objects and looks for entity_name.
Then looks for each component type for instance data.
And that's it really.

---

What about saving entities?
Ew.
Well, instances of schemas, and then write "changed" or "instanced" values. So, in other words, it's up to the user.

---

So now within a system I am looking at this sort of memory access pattern and use case.

for each system
	for each component
		lookup entity
		lookup other necessary components

I think this is fine.
Making the API as simple as possible is the top goal.
Once different components are implemented entites can be created by mix and matching components.
